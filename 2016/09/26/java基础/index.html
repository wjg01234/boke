<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>java基础 | 阿牛传奇</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="\说说******&amp;amp;** **和****&amp;amp; &amp;amp;** **的区别**** &amp;amp;和&amp;amp;&amp;amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为 true 时，整个运算结果才为 true，否则，只要有一方为 false，则结果为 false。 &amp;amp;&amp;amp;还具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础">
<meta property="og:url" content="https:&#x2F;&#x2F;wjg01234.github.io&#x2F;boke&#x2F;2016&#x2F;09&#x2F;26&#x2F;java%E5%9F%BA%E7%A1%80&#x2F;index.html">
<meta property="og:site_name" content="阿牛传奇">
<meta property="og:description" content="\说说******&amp;amp;** **和****&amp;amp; &amp;amp;** **的区别**** &amp;amp;和&amp;amp;&amp;amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为 true 时，整个运算结果才为 true，否则，只要有一方为 false，则结果为 false。 &amp;amp;&amp;amp;还具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-11-03T12:57:15.446Z">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/boke/atom.xml" title="阿牛传奇" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/boke/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/boke/" id="logo">阿牛传奇</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/boke/">首页</a>
        
          <a class="main-nav-link" href="/boke/archives">归档</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/boke/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://wjg01234.github.io/boke"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-java基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/boke/2016/09/26/java%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2016-09-26T11:06:43.000Z" itemprop="datePublished">2016-09-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java基础
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong><em>\</em>说说*****</strong>*&amp;*<strong>* *</strong>*和*<strong>**</strong>*&amp; &amp;*<strong>* *</strong>*的区别****</p>
<p>&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为 true 时，整个运算结果才为 true，否则，只要有一方为 false，则结果为 false。</p>
<p>&amp;&amp;还具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式，例如，对于 if(str != null &amp;&amp; !str.equals(“”)) 表达式，当 str 为 null 时，后面的表达式不会执行，所以不会出现 NullPointerException 如果将&amp;&amp;改为&amp;，则会抛出 NullPointerException 异常。If(x==33 &amp; ++y&gt;0) y 会增长，If(x==33 &amp;&amp; ++y&gt;0)不会增长</p>
<p>&amp;还可以用作位运算符，当&amp;操作符两边的表达式不是 boolean 类型时，&amp;表示按位与操作，我们通常使用 0x0f 来与一个整数进行&amp;运算，来获取该整数的最低 4 个 bit 位，例如，0x31 &amp; 0x0f 的结果为 0x01</p>
<p><strong><em>\</em>c h a r**</strong> <strong><em>\</em>型变量中能不能存贮一个中文汉字*****</strong>*?*<strong>* *</strong>*为什么*<strong>**</strong>*?****</p>
<p>char 型变量是用来存储 Unicode 编码的字符的，unicode 编码字符集中包含了汉字，所以，char 型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在 unicode 编码字符集中，那么，这个 char 型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char 类型的变量也是占用两个字节。</p>
<a id="more"></a>

<p> <strong><em>\</em>“==”*****</strong>*和*<strong>* *</strong>*equals*<strong>* *</strong>*方法究竟有什么区别****</p>
<p>（单独把一个东西说清楚，然后再说清楚另一个，这样，它们的区</p>
<p>别自然就出来了，混在一起说，则很难说清楚）</p>
<p>==操作符专门用来比较两个变量的值是否相等，也就是用于比较变</p>
<p>量所对应的内存中所存储的数值是否相同，要比较两个基本类型的</p>
<p>数据或两个引用变量是否相等，只能用==操作符。</p>
<p>如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块</p>
<p>内存，对象本身占用一块内存（堆内存），变量也占用一块内存，</p>
<p>例如 Objet obj = new Object();变量 obj 是一个内存，new Object()</p>
<p>是另一个内存，此时，变量 obj 所对应的内存中存储的数值就是对</p>
<p>象占用的那块内存的首地址。对于指向对象类型的变量，如果要比</p>
<p>较两个变量是否指向同一个对象，即要看这两个变量所对应的内存</p>
<p>中的数值是否相等，这时候就需要用==操作符进行比较。</p>
<p>equals 方法是用于比较两个独立对象的内容是否相同，就</p>
<p>好比去比较两个人的长相是否相同，它比较的两个对象是独立的。</p>
<p>例如，对于下面的代码：</p>
<p>String a=new String(“foo”);</p>
<p>String b=new String(“foo”);</p>
<p>两条 new 语句创建了两个对象，然后用 a,b 这两个变量分别指向</p>
<p>了其中一个对象，这是两个不同的对象，它们的首地址是不同的，</p>
<p>即 a 和 b 中存储的数值是不相同的，所以，表达式 a==b 将返回 false，</p>
<p>而这两个对象中的内容是相同的，所以，表达式 a.equals(b)将返回</p>
<p>true。</p>
<p>在实际开发中，我们经常要比较传递进行来的字符串内容是否等，</p>
<p>例如，String input = …;input.equals(“quit”)，许多人稍不</p>
<p>注意就使用==进行比较了，这是错误的，随便从网上找几个项目实</p>
<p>战的教学视频看看，里面就有大量这样的错误。记住，字符串的比</p>
<p>较基本上都是使用 equals 方法。</p>
<p>如果一个类没有自己定义 equals 方法，那么它将继承 Object 类</p>
<p>的 equals 方法，Object 类的 equals 方法的实现代码如下： boolean equals(Object o){</p>
<p>return this==o;</p>
<p>}</p>
<p>这说明，如果一个类没有自己定义 equals 方法，它默认的 equals</p>
<p>方法（从 Object 类继承的）就是使用==操作符，也是在比较两个变</p>
<p>量指向的对象是否是同一对象，这时候使用 equals 和使用==会得到</p>
<p>同样的结果，如果比较的是两个独立的对象则总返回 false。如果你</p>
<p>编写的类希望能够比较该类创建的两个实例对象的内容是否相同，</p>
<p>那么你必须覆盖 equals 方法，由你自己写代码来决定在什么情况即</p>
<p>可认为两个对象的内容是相同的。</p>
<p><strong><em>\</em>静态变量和实例变量的区别**</strong></p>
<p>在语法定义上的区别：静态变量前要加 static 关键字，而实例变量</p>
<p>前则不加。</p>
<p>在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。</p>
<p>例如，对于下面的程序，无论创建多少个实例对象，永远都只分配了一个 staticVar 变量，并且每创建一个实例对象，这个 staticVar 就会加 1；但是，每创建一个实例对象，就会分配一个 instanceVar，即可能分配多个 instanceVar，并且每个 instanceVar 的值都只自加了 1 次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class VariantTest</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public static int staticVar = 0;</span><br><span class="line"></span><br><span class="line">public int instanceVar = 0;</span><br><span class="line"></span><br><span class="line">public VariantTest()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">staticVar++;</span><br><span class="line"></span><br><span class="line">instanceVar++;</span><br><span class="line"></span><br><span class="line">System.out.println(“staticVar=” + staticVar</span><br><span class="line"></span><br><span class="line">+ ”,instanceVar=” + instanceVar);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>\</em>是否可以从一个**</strong> <strong><em>\</em>s t a t i c**</strong> <strong><em>\</em>方法内部发出对非**</strong> <strong><em>\</em>s t a t i c**</strong></p>
<p><strong><em>\</em>方法的调用**</strong></p>
<p>不可以。因为非 static 方法是要与对象关联在一起的，必须创建一</p>
<p>个对象后，才可以在该对象上进行方法调用，而 static 方法调用时</p>
<p>不需要创建对象，可以直接调用。也就是说，当一个 static 方法被调用时，可能还没有创建任何实例对象，如果从一个 static 方法中发出对非 static 方法的调用，那个非 static 方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个 static 方法内部发出对非 static 方法的调用。</p>
<p><strong><em>\</em>Integer**</strong> <strong><em>\</em>与**</strong> <strong><em>\</em>int**</strong> <strong><em>\</em>的区别**</strong></p>
<p>int 是 java 提供的 8 种原始数据类型之一。Java 为每个原始类型提供了封装类，Integer 是 java 为 int 提供的封装类。int 的默认值为 0，而 Integer 的默认值为 null，即 Integer 可以区分出未赋值和值为 0 的区别，int 则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为 0 的区别，则只能使用 Integer。在 JSP 开发中，Integer 的默认为 null，所以用 el 表达式在文本框中显示时，值为空白字符串，而 int 默认的默认值为0，</p>
<p>所以用 el 表达式在文本框中显示时，结果为 0，所以，int 不适合作为 web 层的表单数据的类型。</p>
<p>在 Hibernate 中，如果将 OID 定义为 Integer 类型，那么 Hibernate 就可以根据其值是否为 null 而判断一个对象是否是临时的，如果将 OID 定义为了 int 类型，还需要在 hbm 映射文件中设置其 unsaved-value 属性为 0。</p>
<p>另外，Integer 提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer 中还定义了表示整数的最大值和最小值的常量。</p>
<p><strong><em>\</em>请说出作用域**</strong> <strong><em>\</em>public*****</strong>*，*<strong>**</strong>*private*<strong>**</strong>*，*<strong>**</strong>*protected*<strong>**</strong>*，以及不写时的区别****</p>
<p>​    <strong><em>\</em>修饰符**</strong>                                                          <strong><em>\</em>当前类**</strong>           <strong><em>\</em>同 包**</strong>           <strong><em>\</em>子 类**</strong>                  <strong><em>\</em>其他包**</strong></p>
<table>
<thead>
<tr>
<th>public</th>
<th>√</th>
<th>√</th>
<th>√</th>
<th align="center">√</th>
</tr>
</thead>
<tbody><tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td align="center">×</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td align="center">×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java 中，外部类的修饰符只能是 public 或默认，类的成员（包括内部类）的修饰符可以是以上四种。</p>
<p><strong><em>\</em>Overload**</strong> <strong><em>\</em>和**</strong> <strong><em>\</em>Override**</strong> <strong><em>\</em>的区别。*****</strong>*Overloaded*<strong>* *</strong>*的方法是否可以改变返回值的类型*<strong>**</strong>*?****</p>
<p>Overload 是重载的意思，Override 是覆盖的意思，也就是重写。重载 Overload 表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。</p>
<p>重写 Override 表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是 private 类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。</p>
<p>至于 Overloaded 的方法是否可以改变返回值的类型这个问题，要看你倒底想问什么呢？这个题目很模糊。如果几个 Overloaded 的方法的参数列表不一样，它们的返回者类型当然也可以不一样。但我估计你想问的问题是：如果两个方法的参数列表完全一样，是否可以让它们的返回值不同来实现重载 Overload。这是不行的，我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用map.remove(key)方法时，虽然 remove 方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java 就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。</p>
<p>override 可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方</p>
<p>法并且对其重写，以求达到不同的作用。对我们来说最熟悉的覆盖</p>
<p>就是对接口方法的实现，在接口中一般只是对方法进行了声明，而</p>
<p>我们在实现时，就需要实现接口声明的所有方法。除了这个典型的</p>
<p>用法以外，我们在继承中也可能会在子类覆盖父类中的方法。在覆</p>
<p>盖要注意以下的几点：</p>
<p>1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能</p>
<p>达到覆盖的效果；</p>
<p>2、覆盖的方法的返回值必须和被覆盖的方法的返回一致；</p>
<p>3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，</p>
<p>或者是其子类；</p>
<p>4、被覆盖的方法不能为 private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</p>
<p>overload 对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的方法，通过定义不同的输入参数</p>
<p>来区分这些方法，然后再调用时，VM 就会根据不同的参数样式，来</p>
<p>选择合适的方法执行。在使用重载要注意以下的几点：</p>
<p>1、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，</p>
<p>不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数</p>
<p>类型必须不一样，例如可以是 fun(int,float)，但是不能为</p>
<p>fun(int,int)）；</p>
<p>2、不能通过访问权限、返回类型、抛出的异常进行重载；</p>
<p>3、方法的异常类型和数目不会对重载造成影响；</p>
<p>4、对于继承来说，如果某一方法在父类中是访问权限是 priavte，</p>
<p>那么就不能在子类对其进行重载，如果定义的话，也只是定义了一</p>
<p>个新方法，而不会达到重载的效果。</p>
<p><strong><em>\</em>如何实现线程间的通讯**</strong></p>
<p><strong><em>\</em>Java**</strong> 提供了 3 个非常重要的方法来巧妙地解决线程间的通信问题。 </p>
<p>这 3 个方法分别是：wait()、notify()和 notifyAll()。</p>
<p>其中，调用 wait()方法可以使调用该方法的线程释放共享资源的锁，然后从运行态退出，进入等待队列，直到被再次唤醒。而调用</p>
<p>notify()方法可以唤醒等待队列中第一个等待同一共享资源的线程，并使该线程退出等待队列，进入可运行态。调用 notifyAll() 方法可以使所有正在等待队列中等待同一共享资源的线程从等待状态退出，进入可运行状态，此时，优先级最高的那个线程最先执行。显然，利用这些方法就不必再循环检测共享资源的状态，而是在需要的时候直接唤醒等待队列中的线程就可以了。这样不但节省了宝贵的 CPU 资源，也提高了程序的效率。</p>
<p>由 于 wait() 方 法 在 声 明 的 时 候 被 声 明 为 抛 出 InterruptedException 异常，因此，在调用 wait()方法时，需要将它放入 try…catch 代码块中。此外，使用该方法时还需要把它放到一个同步代码段中，否则会出现如下异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;java.lang.IllegalMonitorStateException: current</span><br><span class="line"></span><br><span class="line">thread not owner&quot;</span><br></pre></td></tr></table></figure>

<p><strong><em>\</em>abstract class**</strong> <strong><em>\</em>和**</strong> <strong><em>\</em>interface**</strong> <strong><em>\</em>有什么区别*****</strong>*?****</p>
<p>含有 abstract 修饰符的 class 即为抽象类，abstract 类不能创建的实例对象。含有 abstract 方法的类必须定义为 abstract class， abstract class 类中的方法不必是抽象的。abstract class 类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为 abstract 类型。</p>
<p>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为 public abstract 类型，接口中的成员变量类型默认为 public static final。</p>
<p><strong><em>\</em>下面比较一下两者的语法区别：**</strong></p>
<p>1.抽象类可以有构造方法，接口中不能有构造方法。</p>
<p>2.抽象类中可以有普通成员变量，接口中没有普通成员变量</p>
<p>3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</p>
<p>\4. 抽象类中的抽象方法的访问类型可以是 public，protected 和（默认类型,虽然</p>
<p>eclipse 下不报错，但应该也不行），但接口中的抽象方法只能是 public 类型的，并且默认即为 public abstract 类型。</p>
<p>\5. 抽象类中可以包含静态方法，接口中不能包含静态方法</p>
<p>\6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是 public static final 类型，并且默认即为 public static final 类型。</p>
<p>\7. 一个类可以实现多个接口，但只能继承一个抽象类。下面接着再说说两者在应用上的区别：</p>
<p>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有 Servlet 类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的 Servlet 都继承这个抽象基类，在抽象基类的 service 方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码，伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public abstract class BaseServlet extends HttpServlet</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public final void service(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">记录访问日志</span><br><span class="line"></span><br><span class="line">进行权限判断</span><br><span class="line"></span><br><span class="line">if(具有权限)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">try</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">doService(request,response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catch(Excetpion e)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">记录异常信息</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected abstract void doService(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException;</span><br><span class="line"></span><br><span class="line">//注意访问权限定义成 protected，显得既专业，又严谨，因为</span><br><span class="line"></span><br><span class="line">它是专门给子类用的</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyServlet1 extends BaseServlet</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">protected void doService(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">本 Servlet 只处理的具体业务逻辑代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类方法中间的某段代码不确定，留给子类干，就用模</p>
<p>板方法设计模式。</p>
<p> <strong><em>\</em>S t r i n g**</strong> <strong><em>\</em>是最基本的数据类型吗*****</strong>*?****</p>
<p>基本数据类型包括 byte、int、char、long、float、double、boolean </p>
<p>和 short。</p>
<p>java.lang.String 类是 final 类型的，因此不可以继承这个类、</p>
<p>不能修改这个类。为了提高效率节省空间，我们应该用 StringBuffer 类</p>
<p><strong><em>\</em>String s = “Hello”;s = s + “ world!”;*****</strong>*这两行代码执行后，原始的*<strong>* *</strong>*String*<strong>* *</strong>*对象中的内容到底变了没有？****</p>
<p>没有。因为 String 被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。在这段代码中，s 原先指向一个 String 对象，内容是 “Hello”，然后我们对 s 进行了+操作，那么 s 所指向的那个对象是否发生了改变呢？答案是没有。这时，s 不指向原来那个对象了，而指向了另一个 String 对象，内容为 “Hello world!”，原来那个对象还存在于内存之中，只是 s 这个引用变量不再指向它了。</p>
<p>通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用 String 来代表字符串的话会引起很大的内存开销。因为 String 对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个 String 对象来表示。这时，应该考虑使用 StringBuffer 类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。</p>
<p>同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都 new 一个 String。例如我们要在构造器中对一个名叫 s 的 String 引用变量进行初始化，把它设置为初始值，应当这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line"></span><br><span class="line">private String s;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">public Demo &#123;</span><br><span class="line"></span><br><span class="line">s = &quot;Initial Value&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而非</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = new String(&quot;Initial Value&quot;);</span><br></pre></td></tr></table></figure>

<p>后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为 String 对象不可改变，所以对于内容相同的字符串，只要一个 String 对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他们的 String 类型属性 s 都指向同一个对象。</p>
<p>上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java 认为它们代表同一个 String 对象。而用关键字 new 调用构造器，总是会创建一个新的对象，无论内容是否相同。</p>
<p>至于为什么要把 String 类设计成不可变类，是它的用途决定的。其实不只 String，很多 Java 标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。所以 Java 标准类库还提供了一个可变版本，即 StringBuffer。</p>
<p><strong><em>\</em>是否可以继承**</strong> <strong><em>\</em>S t r i n g**</strong> <strong><em>\</em>类*****</strong>*?***</p>
<p>String 类是 final 类故不可以继承。</p>
<p><strong><em>\</em>String**</strong> <strong><em>\</em>和**</strong> <strong><em>\</em>StringBuffer**</strong> <strong><em>\</em>的区别**</strong></p>
<p>JAVA 平台提供了两个类：String 和 StringBuffer，它们可以储</p>
<p>存和操作字符串，即包含多个字符的字符数据。String 类表示</p>
<p>内容不可改变的字符串。而 StringBuffer 类表示内容可以被修</p>
<p>改的字符串。当你知道字符数据要改变的时候你就可以使用</p>
<p>StringBuffer。典型地，你可以使用 StringBuffers 来动态构造</p>
<p>字符数据。另外，String 实现了 equals 方法，new</p>
<p>String(“abc”).equals(new String(“abc”)的结果为 true,</p>
<p>而 StringBuffer 没有实现 equals 方法，所以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)</p>
<p>的结果为 false。</p>
<p>接着要举一个具体的例子来说明，我们要把 1 到 100 的所有数字拼起来，组成一个串。</p>
<p><strong><em>\</em>StringBuffer**</strong> <strong><em>\</em>与**</strong> <strong><em>\</em>StringBuilder**</strong> <strong><em>\</em>的区别**</strong></p>
<p>StringBuffer 和 StringBuilder 类都表示内容可以被修改的字</p>
<p>符串，StringBuilder 是线程不安全的，运行效率高，如果一个</p>
<p>字符串变量是在方法里面定义，这种情况只可能有一个线程访问</p>
<p>它，不存在不安全的因素了，则用 StringBuilder。如果要在类</p>
<p>里面定义成员变量，并且这个类的实例对象会在多线程环境下使</p>
<p>用，那么最好用 StringBuffer。</p>
<p><strong><em>\</em>数组有没有**</strong> <strong><em>\</em>length()*****</strong>*这个方法*<strong>**</strong>*? String*<strong>* *</strong>*有没有*<strong>**</strong>*length()*<strong>**</strong>*这个方法？****</p>
<p>数组没有 length()这个方法，有 length 的属性。String 有有</p>
<p>length()这个方法。</p>
<p> <strong><em>\</em>try  {}**</strong> <strong><em>\</em>里有一个**</strong> <strong><em>\</em>return**</strong> <strong><em>\</em>语句，那么紧跟在这**</strong></p>
<p><strong><em>\</em>个**</strong> <strong><em>\</em>try**</strong> <strong><em>\</em>后的**</strong> <strong><em>\</em>finally  {}**</strong> <strong><em>\</em>里的**</strong> <strong><em>\</em>code**</strong> <strong><em>\</em>会不会被执行，什么时**</strong></p>
<p><strong><em>\</em>候被执行，在**</strong> <strong><em>\</em>return**</strong> <strong><em>\</em>前还是后*****</strong>*?***</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public	class Test &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(new Test().test());;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int test() &#123;</span><br><span class="line"></span><br><span class="line">int x = 1;</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">return x;</span><br><span class="line"></span><br><span class="line">&#125;finally&#123;</span><br><span class="line"></span><br><span class="line">++x;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>———执行结果 ———</p>
<p>运行结果是 1，为什么呢？主函数调用子函数并得到结果的过程，</p>
<p>好比主函数准备一个空罐子，当子函数要返回结果时，先把结果</p>
<p>放在罐子里，然后再将程序逻辑返回到主函数。所谓返回，就是</p>
<p>子函数说，我    不运行了，你主函数继续运行吧，这没什</p>
<p>么结果可言，结果是在说这话之前放进罐子里的。</p>
<p><strong><em>\</em>final, finally, finalize**</strong> <strong><em>\</em>的区别**</strong></p>
<p>final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。</p>
<p>内部类要访问局部变量，局部变量必须定义成 final 类型，例如，</p>
<p>一段代码……</p>
<p>finally 是异常处理语句结构的一部分，表示总是执行。 finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM 不保证此方法总被调用</p>
<p><strong><em>\</em>运行时异常与一般异常有何异同？**</strong></p>
<p>异常表示程序运行过    中可能出现的非正常状态，运行时异常表</p>
<p>示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。</p>
<p>java 编译器要求方法必须声明抛出可能发生的非运行时异常，</p>
<p>但是并不要求必须声明抛出未被捕获的运行时异常。</p>
<p><strong><em>\</em>JAVA**</strong> <strong><em>\</em>语言如何进行异常处理，关键字：**</strong></p>
<p><strong><em>\</em>throws,throw,try,catch,finally**</strong> <strong><em>\</em>分别代表什么意义？在**</strong> <strong><em>\</em>try**</strong> <strong><em>\</em>块**</strong></p>
<p><strong><em>\</em>中可以抛出异常吗？**</strong></p>
<p>throws 是获取异常</p>
<p>throw 是抛出异常</p>
<p>try 是将会发生异常的语句括起来，从而进行异常的处理，</p>
<p>catch 是如果有异常就会执行他里面的语句，</p>
<p>而 finally 不论是否有异常都会进行执行的语句。</p>
<p><strong><em>\</em>throw 和 throws 的详细区别如下：**</strong></p>
<p>throw 是语句抛出一个异常。</p>
<p>语法：throw (异常对象);</p>
<p>throw e;</p>
<p>throws 是方法可能抛出异常的声明。(用在声明方法时，表示该方法可能要抛出异常)</p>
<p>语 法 ： [( 修 饰 符 )]( 返 回 值 类 型 )( 方 法 名 )([ 参 数 列表])[throws(异常类)]{……}</p>
<p>public void doA(int a) throws Exception1,Exception3{……}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wjg01234.github.io/boke/2016/09/26/java%E5%9F%BA%E7%A1%80/" data-id="ck2l9pbzf0001jowibew81384" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/boke/2016/10/20/oop%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          oop核心思想
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/boke/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/boke/archives/2016/09/">九月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/boke/2016/10/20/oop%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/">oop核心思想</a>
          </li>
        
          <li>
            <a href="/boke/2016/09/26/java%E5%9F%BA%E7%A1%80/">java基础</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 阿牛传奇<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/boke/" class="mobile-nav-link">首页</a>
  
    <a href="/boke/archives" class="mobile-nav-link">归档</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/boke/fancybox/jquery.fancybox.css">
  <script src="/boke/fancybox/jquery.fancybox.pack.js"></script>


<script src="/boke/js/script.js"></script>



  </div>
</body>
</html>